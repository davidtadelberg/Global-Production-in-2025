{
    "contents" : "# main.R\n#\n# David Adelberg\n# david.adelberg@yale.edu\n#\n# Outputs predicted GDP data\n#\n\n# Main function\n# 1) Loads data into memory\n#   a) Data comes from Quandl\n#     i)  UGID  = United Nations Global Indicators\n#     ii) ODA   = IMF Cross Country Macroeconomic Statistics\n#   b) Data may be stored on disk or may be fetched from Quandl\n# 2) Processes Data, calculating country statistics\n#   a) Median Population Growth\n#   b) Median Investment\n#   c) Convergence Indicator (based off Recent Per Capita GDP)\n#   d) Median Inflation\n#   e) Mean Historic GDP Growth Rate\n# 3) Fits a linear model to this data\n# 4) Outputs predicted GDP for the world's countries.\n#\nmain <- function() {\n  options = get_options()\n  init(options)\n  my_data = get_data(options)\n  processed_data = process_data(options, my_data)\n  predictions = make_predictions(options, processed_data)\n  predictions = format_predictions(options, predictions)\n  export(predictions$test, options$files$test_predictions)\n  export(predictions$predictions, options$files$predictions)\n}\n\n# Creates an object containing the program options\n# One can easily change program behavior by modifying this function\nget_options <- function() {\n  dbs = c(\"UGID\", \"ODA\") # These are the databases used\n  selectors = list(UGID = un_select, ODA = imf_select) # These are the functions used to select wanted codes\n  reload = list(r_init = TRUE, # Reload R libraries?\n                quandl_init = TRUE, # Reload quandl?\n                data_init = FALSE, # Redownload country code data from server?\n                get_data = list(UGID = FALSE, ODA = FALSE), # Redownload data from these databases?\n                get_codes = list(UGID = FALSE, ODA = FALSE)) # Redownload codes for these databases?\n  make_predictions = list(print = FALSE, m = 20, seed = 50) # Multiple Imputation by Chained Equations (mice) library options. m is number of imputations.\n  files = list(wanted_data = setNames(as.list(paste(dbs, \"wanted_data.csv\", sep=\"\")), dbs), # UGID => UGIDwanted_data.csv, ODA => ODAwanted_data.csv\n               wanted_codes = setNames(as.list(paste(dbs, \"wanted_codes.csv\", sep=\"\")), dbs), # UGID => UGIDwanted_codes.csv, ODA => ODAwanted_codes.csv\n               test_predictions = \"gdp_test_predictions.csv\", # Output test predictions to this file\n               predictions = \"gdp_predictions.csv\", # Output predictions to this file\n               iso_codes = \"iso_codes.csv\" # ISO codes in this file\n  )\n  dates = list(max_testing_calibration = as.Date(\"2003-12-31\", format=\"%Y-%m-%d\"), # When calibrating model, stop with 2003 data (avoid lookahead bias)\n               most_recent_data = as.Date(\"2014-12-31\", format=\"%Y-%m-%d\"), # Ignore IMF's predictions for the future\n               prediction_date = as.Date(\"2025-12-31\", format=\"%Y-%m-%d\")) # Predict for this date\n  quandl = list(api_key = '4M_9pg6yjNyhuczTH46L') # Quandl API key\n  \n  options = list(dbs = dbs,\n                 selectors = selectors,\n                 reload = reload,\n                 make_predictions = make_predictions,\n                 files = files,\n                 dates = dates,\n                 quandl = quandl\n  )\n}\n\n# Format predictions\n# Create a table with columns country, predicted % growth, actual % growth\nformat_predictions <- function(options, predictions) {\n  colnames(predictions$test) <- c(\"Country\", \n                                  paste(\"Predicted (% growth)\", options$dates$most_recent_data, sep=\", \"),\n                                  paste(\"Actual (% growth, estimated missing data)\", options$dates$most_recent_data, sep=\", \"))\n  predictions$test[,2:3] = (predictions$test[,2:3]-1)*100\n  \n  colnames(predictions$predictions) <- c(\"Country\", \n                                         paste(\"Predicted (% growth)\", options$dates$prediction_date, sep=\", \"))\n  predictions$predictions[,2] = (predictions$predictions[,2]-1)*100\n  \n  predictions\n}\n\n# Outputs a data frame with predictions\n# Data has missing values for some predictors for some countries. Some countries don't even have any GDP data.\n# I use multiple imputation to estimate predictors and predicted values\n# This allows me to estimate GDP for all countries, even those with missing data\nmake_predictions <- function(options, processed_data) {\n  mi_data = mice(processed_data,\n                     print = options$make_predictions$print, # print imputations?\n                     m = options$make_predictions$m, # number of imputations\n                     seed = options$make_predictions$seed) # seed (for repeatability)\n  \n  test = with(mi_data, exp=data.frame(country = country, \n                                         predicted = exp(predict(lm(log(eleven_year_gdp_growth.calibration) ~ \n                                                                      log(median_population_growth.calibration) +\n                                                                      log(median_investment.calibration) +\n                                                                      convergence_indicator.calibration +\n                                                                      log(inflation.calibration) +\n                                                                      log(mean_historic_gdp_growth_rate.calibration)))),\n                                         actual = eleven_year_gdp_growth.calibration))\n\n  predictions = with(mi_data, exp=data.frame(country = country, \n                                         predicted = exp(predict(lm(log(eleven_year_gdp_growth.calibration) ~ \n                                                                      log(median_population_growth.calibration) +\n                                                                      log(median_investment.calibration) +\n                                                                      convergence_indicator.calibration +\n                                                                      log(inflation.calibration) +\n                                                                      log(mean_historic_gdp_growth_rate.calibration)),\n                                                                 newdata = data.frame( # predict expects the data to be .calibration, so that's what I do here.\n                                                                   country=country,\n                                                                   median_population_growth.calibration=median_population_growth.prediction,\n                                                                   median_investment.calibration=median_investment.prediction,\n                                                                   convergence_indicator.calibration=convergence_indicator.prediction,\n                                                                   inflation.calibration=inflation.prediction,\n                                                                   mean_historic_gdp_growth_rate.calibration=mean_historic_gdp_growth_rate.prediction)\n                                                                 ))))\n  # I will average over several data frames in the following lines of code.\n  \n  lapply(list(test=test, predictions=predictions), function(el) {\n    country = el$analyses[[1]]$country\n    results = lapply(el$analyses, function(el) {el[-1]})\n    results = Reduce('+', results) / length(results)\n    cbind(country, results)\n  })\n}\n\n# Gets the country names from an imf data frame\n# The dataframe should be in the format Country - Indicator\nget_imf_countries <- function(df) {\n  names = str_split(colnames(df), \" - \", 2)\n  sapply(names, function(el) {el[1]})\n}\n\n# Gets a subset of a data frame where the colname matches a pattern.\nmatch_df_colnames <- function(df, pattern) {\n  res = df[, grep(pattern, colnames(df))]\n}\n\n# Returns data processed for calibration and data processed for prediction\n# Calculates country statistics from Quandl data: Median Population Growth, Median Investment, Convergence Indicator (based off Log Per Capita GDP), Median Inflation, and Historic GDP growth\n# Calculates Recent GDP growth for calibration.\nprocess_data <- function(options, data) {\n  un_data = data[[1]]\n  imf_data = data[[2]]\n  \n  gdp_growth_rate = function(dta) {\n    gdps = match_df_colnames(dta, \"*Country GDP based on PPP Valuation, USD Billions\")\n    countries = get_imf_countries(gdps)\n    growth_rate = sapply(gdps, function(col) {\n      exp(mean(log((c(col[-1], NA) / col)), na.rm=TRUE))\n    })\n    names(growth_rate) = countries\n    growth_rate\n  }\n  \n  processed_data = lapply(c(options$dates$max_testing_calibration, options$dates$most_recent_data), function(date) {\n    # Ignore dates larger than date\n    modified_data = imf_data[as.Date(imf_data$Date, format=\"%Y-%m-%d\") <= date, ]\n    \n    # Process Population Data\n    popcols = match_df_colnames(modified_data, \"*Population, Millions\")\n    countries = get_imf_countries(popcols)\n    median_pop_growth = sapply(popcols, function(col) {\n      median(c(col[-1], NA) / col, na.rm=TRUE)\n    })\n    population_frame = data.frame(country=countries, median_population_growth = median_pop_growth) # This frame contains median population growth\n    \n    # Process investment Data\n    invcols = match_df_colnames(modified_data, \"*Total Investment, % of GDP\")\n    countries = get_imf_countries(invcols)\n    median_investment = sapply(invcols, function(col) {\n      median(col, na.rm=TRUE)\n    })\n    investment_frame = data.frame(country=countries, median_investment = median_investment) # This frame contains median investment\n    \n    # Process per capita gdp data\n    gdppc = match_df_colnames(modified_data, \"*GDP per Capita at Current Prices\")\n    gdppc = tail(gdppc, 1)\n    countries = get_imf_countries(gdppc)\n    log_gdppc = log(as.numeric(gdppc))\n    convergence_frame = data.frame(country=countries, convergence_indicator = (log_gdppc - median(log_gdppc, na.rm=TRUE)), row.names = NULL) # This frame contains log per capita GDP data\n    \n    # Process inflation (GDP Deflator) data\n    deflator = match_df_colnames(modified_data, \"*GDP Deflator\")\n    countries = get_imf_countries(deflator)\n    inflation_rate = sapply(deflator, function(col) {\n      median(c(col[-1], NA) / col, na.rm=TRUE)\n    })\n    inflation_frame = data.frame(country=countries, inflation=inflation_rate) # This frame contains median inflation rates\n    \n    # Process Historic GDP Growth Rates\n    historic_gdp_frame = data.frame(country=countries, mean_historic_gdp_growth_rate=gdp_growth_rate(modified_data)) # This frame contains historic GDP growth rates\n    \n    # Merge all of these calculated frames\n    frames = list(population_frame, investment_frame, convergence_frame, inflation_frame, historic_gdp_frame)\n    merged = Reduce(function(x,y) merge(x,y, all=TRUE), frames)\n  })\n  \n  dates = as.Date(imf_data$Date, format=\"%Y-%m-%d\")\n  # Get recent GDP growth\n  sub_data = imf_data[dates <= options$dates$most_recent_data & dates >= options$dates$max_testing_calibration, ]\n  gdp_growth = gdp_growth_rate(sub_data)^(nrow(sub_data)-1)\n  \n  current_gdp_frame = data.frame(country=names(gdp_growth), eleven_year_gdp_growth = gdp_growth) # This frame contains GDP growth over 11 years\n  \n  processed_data[[1]] = merge(processed_data[[1]], current_gdp_frame)\n  \n  colnames(processed_data[[1]])[-1] = paste(colnames(processed_data[[1]])[-1], \"calibration\", sep=\".\")\n  colnames(processed_data[[2]])[-1] = paste(colnames(processed_data[[2]])[-1], \"prediction\", sep=\".\")\n  \n  merge(processed_data[[1]], processed_data[[2]])\n}\n  \n\n# If Codes are stored on disk, load them; else, download from server\nget_codes <- function(options, db) {\n  codes_path = options$files$wanted_codes[[db]]\n  if(file.exists(codes_path) & !options$reload$get_codes[[db]]) {\n    import(codes_path)\n  }\n  else {\n    wanted_codes = as.data.frame(get_wanted_api_codes(options, db))\n    export(wanted_codes, codes_path)\n    wanted_codes[[1]]\n  }\n}\n\n# Transform the Quandl Name\n# Into the format Country - Data Field\nprocess_name <- function(name) {\n  db_rest = str_split(name, \"\\\\.\", 2)[[1]]\n  if (db_rest[1] == \"UGID\") {\n    country_rest = str_split(str_split(db_rest[2], \"NATAC_10_\")[[1]][2], \" - \", 2)[[1]] # Use the version 10 system for national accounts collection\n    nn = paste(\n      subset(country_codes.df, Code==country_rest[1])$Name,\n      country_rest[2],\n      sep=\" - \")\n    nn\n  }\n  else if (db_rest[1] == \"ODA\") {\n    country_rest = str_split(db_rest[2], \"_\", 2)[[1]]\n    paste(\n      subset(country_codes.df, Code==country_rest[1])$Name,\n      subset(imf_codes.df, Code==str_split(country_rest[2], \" - \", 2)[[1]][1])$Name,\n      sep=\" - \")\n  }\n}\n\n# Get Wanted Data From Server or Disk\nget_data <- function(options) {\n  sapply(options$dbs, function(db) {\n    data_path = options$files$wanted_data[[db]]\n    if(file.exists(data_path) & !options$reload$get_data[[db]]) { # If the data is on Disk and we don't want to reload it, import the data\n      import(data_path)\n    }\n    else {\n      codes = get_codes(options, db)\n      \n      dta = Quandl(codes, type=\"raw\", collapse=\"annual\")\n      colnames(dta)[-1] = sapply(colnames(dta)[-1], process_name) # Convert API names to English\n      export(dta, data_path)\n      dta\n    }\n  })\n}\n\n# Initialize R libraries, Quandl, and Country code data\ninit <- function(options) { \n  r_init(options)\n  quandl_init(options)\n  data_init(options)\n}\n\n# initialize r libraries\nr_init <- function(options) {\n  if (options$reload$r_init) {\n    if (FALSE %in% sapply(c(\"downloader\", \"rio\", \"bit64\", \"stringr\", \"mice\"),\n                          function(l) {require(l, character.only = TRUE)})) {\n      print(\"error loading libraries\")\n    }\n  }\n}\n\n# initialize Quandl API\nquandl_init <- function (options) {\n  if (options$reload$quandl_init) {\n    if (!require(Quandl)) {\n      print(\"Couldn't use quandl library\")\n    }\n    else {\n      Quandl.api_key(options$quandl$api_key)\n    }\n  }\n}\n\n# Creates a global variable country_codes.df that stores country codes and their translations to English.\n# Also creates a global variable imf_codes.df that stores Quandl IMF API codes and their translations to English. \ndata_init <- function(options) {\n  file_path = options$files$iso_codes\n  if (file.exists(file_path) & !options$reload$data_init) {\n    country_codes.df <<- import(file_path)\n  }\n  else {\n    url = \"https://s3.amazonaws.com/quandl-static-content/API+Descriptions/WHO/ccodes.txt\"\n    download(url, dest=file_path, mode=\"wb\")\n    country_codes.df <<- read.csv(file_path, sep=\"|\")\n    \n    colnames(country_codes.df) = c(\"Code\", \"Name\")\n    \n    # Additional regional codes used by the UN dataset\n    country_codes.df <<- rbind(country_codes.df, data.frame(\n      Code=c(\"UVK\", \"TWN\", 5200, 5310, 5100, 5206, 5204, 5815, 5817, 5803, 5207, 5304, 5001), # IMF and WHO disagree on status of Kosovo and Taiwan\n      Name=c(\"Kosovo\", \"Taiwan\", \"Americas+\",\"Asia+\",\"Africa+\",\"Caribbean+\",\"Central America+\", \n             \"Low Income Food Deficit Countries+\", \"Net Food Importing Developing Countries+\",\n             \"Small Island Developing States+\", \"South America+\", \"South-Eastern Asia+\", \"World+\")\n    ))\n    \n    export(country_codes.df, file_path)\n  }\n  \n  imf_codes.df <<- data.frame(\n    Code = c(\"PPPGDP\", \"NGDP_D\", \"NID_NGDP\", \"NGDPD\", \"LP\", \n             \"BCA_NGDPD\", \"NGDPDPC\"),\n    Name = c(\"Country GDP based on PPP Valuation, USD Billions\",\n              \"GDP Deflator\", \"Total Investment, % of GDP\",\n              \"GDP at Current Prices, USD Billions\", \"Population, Millions\",\n              \"Current Account Balance, % of GDP\", \"GDP per Capita at Current Prices\"\n             )\n  )\n  \n  country_codes.df\n}\n\n# Get API codes for a Quandl database\nquandl_all_db_codes <- function(options, db) {\n   url = \"https://www.quandl.com/api/v3/databases/\"\n   url = paste(url, db, \"/codes\", \"?api_key=\", options$quandl$api_key, sep=\"\")\n   path = paste(db, \"_codes.zip\", sep=\"\")\n   download(url, dest=path, mode=\"wb\")\n   data = read.csv(unzip(path))\n}\n\n# Select from codes where code begins with prefix\nprefix_select <- function(codes, prefix) {\n  pattern = paste(prefix, \"*\", sep=\"\")\n  grep(pattern, codes)\n}\n\n# Get wanted UN National Accounts data\nun_select <- function(codes) {\n  prefix_select(codes, \"UGID/NATAC_10_\") # Use Version 10 of National Accounts Data\n}\n\n# Select wanted API codes in order to get wanted data\nimf_select <- function(codes) {\n  postfixes = c(\"PPPGDP\", \"NGDP_D\", \"NID_NGDP\", \"NGDPD\", \"LP\") # Use these indicators\n  pattern = paste(\"*\", paste(postfixes, collapse=\"|\"), sep=\"\")\n  grep(pattern, codes)\n}\n\n# Gets wanted api codes\nget_wanted_api_codes <- function(options, db) {\n  codes.df = quandl_all_db_codes(options, db)\n  if (is.null(codes.df)) {\n    print(\"Error loading data\")\n  }\n  else {\n    colnames(codes.df) = c(\"Code\", \"Explanation\")\n    codes.df$Code[options$selectors[[db]](codes.df$Code)]\n  }\n}\n\nmain()",
    "created" : 1447900273039.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "25643439",
    "id" : "1587EB6",
    "lastKnownWriteTime" : 1449605829,
    "path" : "~/Documents/CS50/FinalProject/R/main.R",
    "project_path" : "main.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}